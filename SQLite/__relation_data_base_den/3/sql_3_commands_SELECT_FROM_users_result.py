# SQLite #3: команды-запросы SELECT и INSERT при работе с таблицами БД
import sqlite3 as sq

# устанавливаем связь с файлом который находится в каталоге
with sq.connect("sales.db") as con:     # контекст менеджера автоматически закрывает базу данных
# con = sq.connect("saper.db")  # !!!!!!!Так открывать БД нельзя
    cur = con.cursor()  # Для взаимодействия с базой данных используем объект Cursor
                        # метод cursor() возвращает экземпляр класса cursor и через переменную cur
                        # осуществляем непосредственно работу


# INSERT – добавления записей. Ее синтаксис следующий:
# INSERT INTO <table_name> (<column_name1>, <column_name2>, ...) VALUES (<value1>, <value2>, …)
# или так:
# INSERT INTO <table_name> VALUES (<value1>, <value2>, …) 

# DB SQ
# INSERT INTO users VALUES(1, 'Alabama', 1, 3200, 18)
# Ctrl + Enter
# INSERT INTO users (user_id, names_of_states, payments, delivery_time) VALUES(2, 'Colorado ', 3900, 21)
# Ctrl + Enter


# SELECT - используется при составлении SQL-запросов.
# Она отвечает за выборку данных из таблицы, синтаксис:
#      поля кот. выбираем из  таблицы  
# SELECT col1, col2, … FROM <table_name> 

# DB SQ
# SELECT names_of_states, payments FROM users
# Ctrl + Enter
# SELECT * FROM users    - выбираем все поля из таблицы 
# Ctrl + Enter


# Если нам нужно добавить фильтр для выбираемых записей,
# то это делается с помощью ключевого слова WHERE, которое записывается после имени таблицы:
# Синтаксис:
# SELECT col1, col2, … FROM <table_name> WHERE <условие>

# Например, отберем все записи со значением платежей меньше 3900: 
# SELECT * FROM users WHERE payments < 3900
# Ctrl + Enter


# Все приведенные SQL-запросы можно выполнять непосредственно из программы:
# WHERE записывает логическое выражение и в качестве сравнения можно использовать следующие операторы:
# = или ==  проверка на равенство
# >, <, >=, <=,
# !=        неравно
# BETWEEN   ключевое слово  

# Например, выберем все записи с числом продаж в диапазоне от 3000 до 5000
# SELECT * FROM users WHERE payments BETWEEN 3000 AND 5000

# Например, выберем записи с платежами равными 5600
# SELECT * FROM users WHERE payments = 5600

# Составные условия
# Часто при описании фильтра требуется учитывать значения сразу нескольких столбцов.
# Например, выбрать всех покупателей штата Florida и с платежами более 4000.
# Здесь уже нужно использовать составное условие.

# Для этого дополнительно используются следующие ключевые слова:
#                    истина   истина
## AND – условное И: exp1 AND exp2. Истинно, если одновременно истинны exp1 и exp2.
## OR – условное ИЛИ: exp1 OR exp2. Истинно, если истинно exp1 или exp2 или оба выражения.
## NOT – условное НЕ: NOT exp. Преобразует ложное условие в истинное и, наоборот, истинное – в ложное.
## NOT - самый высокий приоритет
## IN – вхождение во множество значений: col IN (val1, val2, …)
## NOT IN – не вхождение во множество значений: col NOT IN (val1, val2, …) - 

# Например, выыберем покупателей c временем длставки менее 21 час и с платежами менее 4000. Или, так:
# SELECT * FROM users WHERE delivery_time <= 21 AND payments < 4000
# эквивалентная запись
# SELECT * FROM users WHERE delivery_time IN(18, 21) AND payments < 4000
# или выберем покупателя мужчину или женщину
# те, у которых мужской пол (sex = 1)
# SELECT * FROM users WHERE delivery_time IN(18, 21) AND payments < 4000 OR sex = 1
#                           __________________________1_________________ _2________              
# Этот пример показывает важность приоритетов: приоритет у операции AND выше, чем у OR, поэтому AND выполняется раньше OR.
# Изменить приоритет
# SELECT * FROM users WHERE delivery_time IN(18, 21) AND (payments <= 3900 OR sex = 1)

# Сортировка по указанному столбцу
# Например, мы хотим выбрать все платежи менее 4000 и отсортировать их по возрастанию возраста

# SELECT * FROM users
# WHERE delivery_time IN(18, 21) AND payments <= 4000 OR sex = 1
# ORDER BY payments 
#                   DESC  - сортировка в обратном порядке
#                   ASC   - сортировка по возрастанию 

# LIMIT 2   # - сколько записей будем отбирать из нашей выборки  
# В реальных таблицах число записей может быть очень большим.
# Например, число платежей может достигать тысяч или даже десятков тысяч.
# И, представьте, что из всего этого числа нам нужно взять первых 10 платежей
# с наибольшим числом очков, чтобы сформировать ТОП-10 лучших.
# Для этого в команде SELECT используется еще один оператор – LIMIT,
# который записывает в самом конце и имеет следующие синтаксисы:
# LIMIT <max> [OFFSET offset]
# LIMIT <offset, max>

# Для демонстрации работы этого оператора, добавим в таблицу еще несколько записей:
# SELECT * FROM users
# WHERE payments > 4000 ORDER BY delivery_time DESC LIMIT 5
# или пропустить первую запись
# WHERE payments > 4000 ORDER BY delivery_time DESC LIMIT 5 OFFSET 1
# или смещение записей 
# WHERE payments > 4000 ORDER BY delivery_time DESC LIMIT 2, 5 


# Работа с выборкой в программе на Python
# Все приведенные SQL-запросы можно выполнять непосредственно из программы:

#   метод fetchall для получения результатов отбора SQL-запроса
    cur.execute("SELECT * FROM users WHERE payments > 3000 ORDER BY delivery_time DESC LIMIT 5")
#    result = cur.fetchall()
#    print(result)
        # result будет ссылаться на упорядоченный список, состоящий из кортежей с данными таблицы:
        # далее можем брать данные с программы и что-нибудь с ними делать


#   Например, переберем последовательно, используя Cursor в качестве итерируемого объекта:
#    for result in cur:
#        print(result)
# Этот последний вариант более предпочтителен когда число выбираемых записей может быть велико.
# Тогда мы не формируем список, а последовательно выбираем из БД и тут же их обрабатываем.
# Такой подход существенно экономит память.


# Есть еще два метода, которые выдают результат выборки из таблицы:
# fetchmany(size) – возвращает число записей не более size;
# fetchone() – возвращает первую запись.
# Вызовим их:
    result = cur.fetchone()         # сылается на первую запись 
    result2 = cur.fetchmany(2)      # ссылается на первые две записи
    print(result)
    print(result2)                  # возвращает список из двух кортежей, двух записей




# Вот так можно добавлять записи в таблицу БД и делать выборку из нее.
# Здесь мы рассмотрели лишь базовый вариант работы команды SELECT.
# Она имеет гораздо больший функционал.
# Например, выбрать записи сразу из нескольких таблиц, производить группировку записей,
# реализовывать различные агрегаторы.





