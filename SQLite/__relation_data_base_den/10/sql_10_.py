import sqlite3 as sq
# SQLite #10: API - методы fetchall, fetchmany, fetchone, iterdump

# Продолжим изучение API для работы с SQLite на языке Python и вспомним о способе извлечения данных из запросов.
# Об этом мы уже рассматривали методы:
# fetchall() – возвращает число записей в виде упорядоченного списка;
# fetchmany(size) – возвращает число записей не более size;
# fetchone() – возвращает первую запись.

# Для начала наполним БД cars записями
cars = [
    ('Audi', 52642),
    ('Mercedes', 57127),
    ('Skoda', 9000),
    ('Volvo', 29000),
    ('Bentley', 350000)
]

# воспользуемся мейжером контекста, одключаемся к БД
with sq.connect("cars.db") as con:
    con.row_factory = sq.Row    # получить словарь в виде ключ и значение - объект row 
    cur = con.cursor()
 
    cur.executescript("""CREATE TABLE IF NOT EXISTS cars (
            car_id INTEGER PRIMARY KEY AUTOINCREMENT,
            model TEXT,
            price INTEGER)
    """)

    # запрос - executemany - весь наш список помещаем в таблицу cars этой БД
#    cur.executemany("INSERT INTO cars VALUES(NULL,?, ?)", cars)

    # выполним запрос - чтобы в программе на Python получить доступ к выборке, используем методы
    cur.execute("SELECT model, price FROM cars")

    # метод fetchall() – возвращает все записи в виде упорядоченного списка
    # из запроса SELECT model, price FROM cars
    # в консоли увидим все записи, которые присутствуют в нашей таблице
#    rows = cur.fetchall()
#    print(rows)

    # метод fetchone() – берет только первую запись
#    rows = cur.fetchone()
#    print(rows)

    # метод fetchmany() – который вернет из первых 5 записей только первые 4
#    row = cur.fetchmany(4)
#    print(row)

    # после формирования выборки сам экземпляр класса cur ожно использовать как
    # переборной объект - перебирать в цикле
    # на каждой итерации цикла получим запись
    # преимущество цикла - экономия памяти, на каждой итерации цикла берем только одну запись
    # только эту запись храним в памяти и можем сразу обработать, часто это эффективно
    # все выходные данные цикла - это кортежи, иногда это не очень удобно   
#    for result in cur:
#        print(result)

    # иногда удобно использовать вместо кортежа словарь (т.е. набор данных в виде ключ и значение)
    # чтоб на выходе получить словарь в виде ключ и значение добавим вначале
    # con.row_factory = sq.Row
    for results in cur:
            print(results['model'], results['price'])
            # указываем поля которые фигурируют в выборке
            # данные отображаются модель и цена
            # иногда это удобно, т.к. поля могут быть записаны в разном порядке
            # бращаемся к полям не по индексу а по названию полей






















            
    

