import re
import csv


import csv
exampleFile = open('map.csv')
exampleReader = csv.reader(exampleFile)
exampleData = list(exampleReader)
print(exampleData)




# Давайте в качестве практического примера рассмотрим парсинг вот такого csv-файла:
# Будем выделять lon lat с определенными значениями
with open("map.csv", "r") as f:
    lat = []
    lon = []
    for text in f:
        match = re.findall(r"<point\s+[^>]*?lon;([\"\'])([0-9.,]+)\1\s+[^>]*lat=([\"\'])([0-9.,]+)\1", text)
        print(match)
 
    print(lon, lat, sep="\n")

# Мы здесь открываем файл на чтение с использованием менеджера контекста а,
# затем, построчно считываем из файла информацию.
# Каждая строчка будет помещаться в переменную text.
# Далее выполняется анализ с помощью шаблона
# Для каждой строки применяем регулярное выражение, выделяя атрибуты lon и lat.
# начала обращаемся к тегу point. Затем ищем ключ lon и для него выделяем соотв. значения
# Тоже самое для lat

#Сначала идут пустые строчки, где не соответствуют шаблону
# В тех строчках, где нет данных атрибутов, имеем пустую коллекцию,
# а где формат совпадает, получаем четыре значения из сохраняющих круглых скобок.
# Здесь нам нужны значения с индексом 1 – для lon и 3 – для lat.
# [('"', '40.8482', '"', '52.6274')]
# И, записывая все в такую программу:

with open("map.csv", "r") as f:
    lat = []
    lon = []
    for text in f:
        match = re.findall(r"<point\s+[^>]*?lon=([\"\'])([0-9.,]+)\1\s+[^>]*lat=([\"\'])([0-9.,]+)\1", text)
        if len(match) > 0:
            lon.append(match[0][1])
            lat.append(match[0][3])
 
    print(lon, lat, sep="\n")
# делаем проверку, если match одержит либо какие-то данные, это не пустая квадратная скобка,
# то мы в lon добавляем это значение, берем 0 индекс, это кортеж будет. У этого
# кортежа берем первый индекс. Для lat берем 3 индекс.
# Результат - сформировано два списка, lon и lat, которые состоят из данных считанного
# с этого файла



# Но, как вы понимаете, это не лучшая реализация поставленной задачи.
# Что если регулярное выражение изменится и индексы станут другими?
# Придется поправлять весь программный код, связанный с этим шаблоном!
# Это не очень удобно. Здесь лучше использовать имена сохраняющих групп,
# а затем, обращаться к данным по этим именам. Поэтому перепишем программу так:
# Воспользуемся другим методом search(), который возвращает не просто коллекцию,
# а объект из которого можно получить словарь, содержащий коллекцию сохраненных именованных групп.
# и проверка, если совпадение было найдено, то мы берем словарь с сохраняющими группами
# и проверяем есть ли в этом слловаре ключи lon и lat. Если они есть то добавляем
# соответствующие значения. Получаем теже значения, но мы использовали имена
# сохраняющих груп. Это удобно, если в будущем шаблон изменится, программа остается неизменной.
# Также по именам обращаемся к данным и добавляем их в соответствующие коллекции.
#
with open("map.csv", "r") as f:
    lat = []
    lon = []
    for text in f:
        match = re.search(r"<point\s+[^>]*?lon=([\"\'])(?P<lon>[0-9.,]+)\1\s+[^>]*lat=([\"\'])(?P<lat>[0-9.,]+)\1", text)
        if match:
            v = match.groupdict()
            if "lon" in v and "lat" in v:
                lon.append(v["lon"])
                lat.append(v["lat"])
 
    print(lon, lat, sep="\n")


